---
created: 2024-08-03T19:28
updated: 2024-08-03T19:28
---
## 多线程之间数据通讯

`queue.Queue` 可以用于多线程之间的、线程安全的数据通信

使用 `q.put(item)` 和 `q.get()` 来添加和获取元素, 这两个方法有一点它们都是阻塞的, 意思是说当里面没有内容的时候呢, `q,get()`, 直到里面有了数据把它取出来, `q.put(item)` 的对应的是当他们队列满了以后呢, 也会等待, 直到有一个空闲的位置, 你才能放得进去

```python
# 1、导入类库
import queue

# 2、创建Queue
q = queue.Queue()

# 3、添加元素
q.put(item)

# 4、获取元素
item = q.get()

# 5、查询状态

#查看元素的多少
q.qsize()
#判断是否为空
q.empty()
#判断是否已满
q.full()
```


## 线程安全


线程安全指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。

由于线程的执行随时会发生切换，就造成了不可预料的结果，出现线程不安全

### Lock 用于解决线程安全问题


- Try-finally 模式
- With 模式


## Python 好用的线程池 ThreadPoolExecutor

新建线程系统需要分配资源、终止线程系统需要回收资源如果可以重用线程，则可以减去新建/终止的开销

**好处:**

1、提升性能：因为减去了大量新建、终止线程的开销，重用了线程资源；
2、适用场景：适合处理突发性大量请求或需要大量线程完成任务、但实际任务处理时间较短 
3、防御功能：能有效避免系统因为创建线程过多，而导致系统负荷过大相应变慢等问题 
4、代码优势：使用线程池的语法比自己新建线程执行线程更加简洁


```python
from concurrent.futures import ThreadPoolExecutor, as_completed


with ThreadPoolExecutor() as pool:

    # map函数，简单，注意map的结果和入参是顺序对应的
    results = pool.map(craw, urls)

    for result in results:
        print(result)

    # 第二种 future模式，更强大
    futures = [pool.submit(craw, url) for url in urls]

    for future in futures:
        print(future.result())
        
    # as_completed 顺序是不固定的
	for future in as_completed(futures):
		print(future.result())
		
	# 用字典对应保存
 	futures ={}
 	for url,html in htmls:
 		future = pool.submit(blog_spider.parse,html)
 		futures[future] = url

	for future , url in futures.items():
		print(url,future.result())
    

```